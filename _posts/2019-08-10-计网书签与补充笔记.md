---
layout: post
title:  "计网书签与补充笔记"
date:   2019-08-10
desc: ""
keywords: ""
categories: [杂项]
tags: [计算机网络]
icon: icon-html
---
整理自
[王先生架构 - TCP协议详解](https://www.cnblogs.com/buxiangxin/p/8336022.html)

[深入浅出 TCP/IP 协议栈](https://www.cnblogs.com/onepixel/p/7092302.html)

[TCP 详解](https://blog.csdn.net/sinat_36629696/article/details/80740678)

[大小端及网络字节序](https://blog.csdn.net/z_ryan/article/details/79134980)

[TCP的快速重传机制](https://blog.csdn.net/whgtheone/article/details/80983882)



<br />
### 1、应用层

向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等


<br />
### 2、传输层

提供应用程序间的通信。其功能包括：一、格式化信息流；二、提供可靠传输。为实现后者，传输层协议规定接收端必须发回确认，并且假如分组丢失，必须重新发送

<br />
### 3、网络层

负责相邻计算机之间的通信。其功能包括三方面

一、处理来自传输层的分组发送请求，收到请求后，将分组装入IP数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口。

二、处理输入数据报：首先检查其合法性，然后进行寻径--假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报。

三、处理路径、流控、拥塞等问题

<br />
### TCP / IP

IP 是无连接的，用于计算机之间的通信。IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路，IP 负责将每个包路由至它的目的地

TCP 用于应用程序之间的通信。当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。

<br />
### 三次握手四次挥手

**为什么不用两次握手？**

主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。 

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

**为什么建立连接是三次握手，关闭连接确是四次挥手呢？**

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 

而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

<br />
### TCP 保证可靠性的机制

+ 校验和
+ 连接管理：经过三次握手建立连接, 四次挥手断开连接
+ 序列号(按序到达)、确认应答(ACK机制)

顺序是用一个序列号来保证的。响应包内也包括一个序列号，表示接收方准备好这个序列号的包。在TCP传送一个数据包时，它会把这个数据包放入重发队列中，同时启动计时器，如果收到了关于这个包的确认信息，便将此数据包从队列中删除，如果在计时器超时的时候仍然没有收到确认信息，则需要重新发送该数据包

+ 超时重传
+ 流量控制

TCP支持根据接收端的处理能力, 来决定发送端的发送速度。接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 “窗口大小” 字段, 
通过ACK通知发送端; 

+ 拥塞控制

TCP引入 **慢启动** 机制, 先发少量的数据, 探探路, 摸清当前的网络拥堵状态以后, 再决定按照多大的速度传输数据
在此引入一个概念 **拥塞窗口**

发送开始的时候, 定义拥塞窗口大小为1;

每次收到一个ACK应答, 拥塞窗口加1;

每次发送数据包的时候, 将拥塞窗口和接收端主机反馈的窗口大小做比较, 取较小的值作为实际发送的窗口

为了不增长得那么快, 此处引入一个名词叫做 **慢启动的阈值**, 当拥塞窗口的大小超过这个阈值的时候, 不再按照指数方式增长, 而是按照线性方式增长

当TCP开始启动的时候, 慢启动阈值等于窗口最大值

在每次超时重发的时候, 慢启动阈值会变成原来的一半, 同时拥塞窗口置回1

<br />
### TCP 提高性能的机制

+ 滑动窗口

窗口大小指的是无需等待确认应答就可以继续发送数据的最大值

+ 快速重传

由于TCP采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK。如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出，大大提高了效率。这便是快速重传机制

+ 延迟应答

如果接收数据的主机立刻返回ACK应答, 这时候返回的窗口可能比较小

+ 捎带应答

<br />
### 大小端及网络字节序

**大端字节序（Big Endian）**：最高有效位存于最低内存地址处，最低有效位存于最高内存处

**小端字节序（Little Endian）**：最高有效位存于最高内存地址，最低有效位存于最低内存处

UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节；而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节

所以说,**网络字节序是大端字节序**

在实际中，当在两个存储方式不同的主机上传输时，需要借助字节序转换函数