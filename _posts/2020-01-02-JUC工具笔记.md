---
layout: post
title:  "JUC工具笔记"
date:   2020-01-02
desc: ""
keywords: ""
categories: [Java]
tags: []
icon: icon-html
---

Java 并发编程实战 + 并发工具详解 课程笔记 

<br />
# ThreadLocal

### `ThreadLocal 的两大使用场景`

+ 每个线程需要一个**独享的对象**（ 通常是工具类，典型的有 SimpleDateFormat 和 Random ）

```
SimpleDateFormat dateFormat = ThreadSafeFormatter.dateFormatThreadLocal.get();

......

// 在 ThreadLocal 第一次 get 的时候把对象给初始化出来，
// 对象的初始化时机可以由我们控制

class ThreadSafeFormatter {
	public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal = new ThreadLocal<SimpleDateFormat>() {
		@Override
		protected SimpleDateFormat initialValue() {
			return new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
		}
	};
}
```

+ 每个线程内需要**保存全局变量**（ 例如在拦截器中获取用户信息 ），可以让不同方法直接使用，避免参数传递的麻烦

在线程生命周期内，都通过这个静态 ThreadLocal 实例的 get() 方法取得自己 set 过的那个对象，强调了同一个请求内（ 同一个线程内 ）不同方法间的共享，不需重写 initialValue() 方法，但是必须手动调用 set() 方法

这样无需 synchronized，不影响性能，也无需层层传递参数

```
// 对象的生成时机不由我们随意控制

class UserContextHolder {
	public static ThreadLocal<User> holder = new ThreadLocal<>();
}

class Service1 {
	public void process() {
		User user = new User("Tom");
		UserContextHolder.holder.set(user);
		new Service2.process();
	}
}

class Service2 {
	public void process() {
		User user = UserContextHolder.holder.get();
		System.out.println(user.name);
	}
}
```

<br />
### `ThreadLocal 的两个作用`

1. 让某个需要用到的对象在线程间隔离（ 每个线程都有自己的独立的对象 ）
2. 在任何方法中都可以轻松获取到该对象

<br />
### `ThreadLocal 原理`

<div><img src="https://raw.githubusercontent.com/Tianye-Zheng/Tianye-Zheng.github.io/master/PostPictures/2019-winter/8.png" width = "420" height =
"430" /></div>

<br />
### `ThreadLocal 重要方法`

+ `T initialValue()` ： 该方法返回当前线程对应的 “初始值”，这是一个延迟加载的方法，只有在调用 get 的时候，才会触发

+ `void set(T t)` ： 为这个线程设置一个新值

+ `T get()`

+ `remove()`

<br />
### `ThreadLocalMap 类`

ThreadLocalMap 解决散列冲突采用**线性探测法**，也就是如果发生冲突，就继续找下一个空位置，而不是用链表拉链

<br />
### `两种使用场景殊途同归`

通过源码分析看出，setInitialValue 和直接 set 最后都是利用 **map.set()** 方法来设置值

也就是说，最后都会对应到 ThreadLocalMap 的一个 Entry，只**不过是起点和入口不一样**

<br />
### `ThreadLocal 注意点`

`内存泄漏` ： ThreadLocalMap 中的每个 Entry 都是一个对 key （ ThreadLocal ）的弱引用，同时，每个 Entry 都包含了一个对 value 的强引用

弱引用的特点是，如果这个对象只被弱引用关联（ 没有任何强引用关联 ），那么这个对象就可以被回收

通常情况下，当线程终止，保存在 ThreadLocal 里的 value 会被垃圾回收，因为没有任何强引用了

但是，如果线程不终止，比如线程需要保持很久，那么 key 对应的 value 就不能被回收，因为有以下的调用链：

`Thread -> ThreadLocalMap -> Entry(key 为 null) -> value`

因为 value 和 Thread 之间还存在这个强引用链路，所以导致 value 无法回收，就可能会出现 OOM

JDK 已经考虑到了这个问题，所以在 **set， remove， rehash** 方法中会**扫描 key 为 null 的 Entry，并把对应的 value 设置为 null**，这样 value 对象就可以被回收

但是如果一个 ThreadLocal 不被使用，那么实际上 set，remove， rehash 方法也不会被调用，如果同时线程又不停止，那么调用链就一直存在，那么就导致了 value 的内存泄漏

`如何避免内存泄漏（ 阿里规约 ）` ： 调用 remove 方法，就会删除对应的 Entry 对象，可以避免内存泄漏，所以使用完 ThreadLocal 之后，应该调用 remove 方法

`空指针异常` ： 在 get 之前，必须先 set，否则可能会报空指针异常，注意装箱拆箱时

`共享对象` ： 如果在每个线程中 ThreadLocal.set() 进去的东西本来就是多线程共享的同一个对象，比如 static 对象，那么多个线程的 ThreadLocal.get() 取得的还是这个共享对象本身，还是有并发访问问题

优先使用框架提供的，避免上述问题，例如

Spring 中的 DateTimeContextHolder 类，RequestContextHolder 类

**每次 HTTP 请求都对应一个线程，线程之间相互隔离，这就是 ThreadLocal 的典型应用场景**

<br />
# 线程池

<br />
### `线程池适用场景`

+ 服务器接受到大量请求时，适用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率，例如 Tomcat 服务器也使用了线程池来实现

+ 实际上，在开发中，如果需要创建 5 个以上的线程，那么就可以使用线程池来管理

<br />
### `创建和停止线程池`

<div><img src="https://raw.githubusercontent.com/Tianye-Zheng/Tianye-Zheng.github.io/master/PostPictures/2019-winter/9.png" width = "500" height =
"430" /></div>

<div><img src="https://raw.githubusercontent.com/Tianye-Zheng/Tianye-Zheng.github.io/master/PostPictures/2019-winter/10.png" width = "500" height =
"430" /></div>

`keepAliveTime` ： 如果线程池当前的线程数多于 corePoolSize， 那么多于的线程空闲时间超过 keepAliveTime，它们就会被终止

`ThreadFactory` ： 新的线程是由 ThreadFactory 创建的，默认使用 `Executors.defaultThreadFactory()` ，创建出来的线程都在同一个线程组，拥有同样的优先级并都不是守护线程，如果自己指定 ThreadFactory，那么就可以定制这些属性

`workQueue` ： 工作队列，常见 3 种

+ 直接交接 ： SynchronousQueue
+ 无界队列 ： LinkedBlockingQueue
+ 有界队列 ： ArrayBlockingQueue

线程池手动创建更好，因为这样可以让我们更加明确线程池的运行规则，避免资源耗尽的风险

```
// 演示 newFixedThreadPool
// 由于传进去的 LinkedBlockingQueue 是没有容量上限的，所以当
// 请求数越来越多，会占用大量内存，可能会导致 OOM

public static void main(String[] args) {
	
	// 新建线程池
	ExecutorService executorService = 
	Executors.newFixedThreadPool( 4 );
	
	for(int i = 0; i < 1000; i++) {
		executorService.execute(new Task());
	}
}

class Task implements Runnable {
	@Override
	public void run() {
		try {
			Thread.sleep(500);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(Thread.currentThread().getName());
	}
}
```

```
// 演示 newSingleThreadExecutor，同理
// newCachedThreadPool

public static void main(String[] args) {
	
	ExecutorService executorService = 
	Executors.newSingleThreadExecutor();
	
	for(int i = 0; i < 1000; i++) {
		executorService.execute(new Task());
	}
}
```

```
// 演示 newScheduledThreadPool
// 支持定时及周期性任务执行的线程池
// 跟时间相关的工作

public static void main(String[] args) {
	
	ScheduledExecutorService threadPool = 
	Executors.newScheduledThreadPool( 10 );
	
	// threadPool.schedule( new Task(), 5, TimeUnit.SECONDS );
	threadPool.scheduleAtFixedRate( new Task(), 1, 3, TimeUnit.SECONDS );
}
```
<br />
### `线程池里的线程数量设定为多少比较合适？`

+ CPU 密集型（ 加密、计算hash等 ）：最佳线程数为 CPU 核心数的 1-2 倍左右

+ 耗时 IO 型（ 读写数据库，文件，网络读写等 ）：最佳线程数一般会大于 CPU 核心数很多倍

<br />
### `停止线程池的正确方法`

+ `shutdown` ： 把存量任务执行完再停止，新提交任务将抛出异常

+ `isShutdown`

+ `isTerminated` ： 是不是已经完全终止了

+ `awaitTermination` ： 测试一段时间内线程池是否完全终止

+ `shutdownNow` ： 立刻关闭

<br />
### `拒绝任务的时机`

+ 当 Executor 关闭时，提交新任务会被拒绝

+ 以及当 Executor 对最大线程和工作队列容量使用有限边界并且已经饱和时

<br />
### `4种拒绝策略`

+ AbortPolicy ： 直接抛出异常
+ DiscardPolicy ： 默默地丢弃任务
+ DiscardOldestPolicy ： 丢弃最老的
+ CallerRunsPolicy ： 让提交任务的线程去执行

<br />
### ` “钩子方法”`

线程池中每个任务执行前后都可以放钩子方法

```
// 扩展一个可暂停的线程池

public class PauseableThreadPool extends ThreadPoolExecutor {

   // 自动生成一些方法的实现
	......
	
	private final ReentrantLock lock = new ReentrantLock();
	private Condition unpaused = lock.newCondition();
	private boolean isPaused;
	
	public void pause() {
		lock.lock();
		try { // 避免出现锁永远不释放的情况
			isPaused = true;
		} finally {
			lock.unlock();
		}
	}
	
	public void resume() {
		lock.lock();
		try {
			isPaused = false;
			unpaused.signalAll();
		} finally {
			lock.unlock();
		}
	}
	
	@Override
	protected void beforeExecute(Thread t, Runnable r) {
		super.beforeExecute(t, r);
		lock.lock();
		try {
			while (isPaused) {
				unpaused.await();
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
	}
}
```

<br />
### `线程池实现原理及源码分析`

线程池组成部分

+ 线程池管理器

+ 工作线程

+ 任务队列

+ 任务接口（ Task ）

<div><img src="https://raw.githubusercontent.com/Tianye-Zheng/Tianye-Zheng.github.io/master/PostPictures/2019-winter/11.png" width = "400" height =
"500" /></div>

`线程池实现任务复用的原理`

+ 相同的线程执行不同的任务

不断地从阻塞队列中把一个一个的 Runnable 的 Task 拿到，并直接调用其 run 方法，这样就能实现用相同的线程不断地执行 run 方法

<br />
### 线程池状态

+ `Running` ：接受新任务并处理排队任务

+ `shutdown` ：不接受新任务，但处理排队任务

+ `stop` ：不接受新任务，也不处理排队任务

+ `tidying` ：所有任务都已终止，workerCount 为零时，线程会转换到 tidying 状态，并将运行 terminate() 钩子方法

+ `terminated` ：terminate() 运行完成

<br />
### 使用线程池注意点

+ 避免任务堆积
+ 避免线程数过度增加
+ 排查线程泄漏

<br />
# 原子类

原子类的作用和锁类似，是为了保证并发情况下线程安全，不过原子类相比于锁，有一定的优势

+ **粒度更细** ：原子变量可以把竞争范围缩小到变量级别，这是我们可以获得的最细粒度的情况了，通常锁的粒度都要大于原子变量的粒度

+ **效率更高** ：通常，使用原子类的效率会比使用锁的效率更高，除了高度竞争的情况

<div><img src="https://raw.githubusercontent.com/Tianye-Zheng/Tianye-Zheng.github.io/master/PostPictures/2019-winter/12.png" width = "400" height =
"500" /></div>

<br />
### 把普通变量升级为具有原子功能

+ AtomicIntegerFieldUpdater 对普通变量进行升级

+ 使用场景 ： 偶尔需要一个原子 get-set 操作

```
public class AtomicIntegerFieldUpdaterDemo {
	static Candidate tom;
	static Candidate peter;
	
	public static class Candidate {
		volatile int score;
	}
	
	public static AtomicIntegerFieldUpdater<Candidate>
	scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, "score");
	
	@Override
	public void run() {
		for (int i = 0; i < 10000; i++) {
			// 对比两种方式
			peter.score++;
			scoreUpdater.getAndIncrement(tom);
		}
	}
}
```

<br />
# CAS 原理

`原子类、乐观锁的底层原理`

我认为 V 的值应该是 A，如果是的话那我就把它改成 B，如果不是 A ( 说明被别人修改过了 )，那我就不修改了，避免多人同时修改导致出错

CAS 有三个操作数：内存值 V，预期值 A，要修改的值 B，当且仅当预期值和内存值相同时，才将内存值修改为 B，否则什么都不做，最后返回现在的 V 值

使用 CPU 的特殊指令，由 CPU 保证其原子性

```
// 模拟 CAS 操作，等价代码
public class SimulatedCAS {
	
	private volatile int value;
	
	// 这个方法对应了那一条 CAS 指令
	public synchronized int compareAndSwap(int expectedValue, int newValue) {
		int oldValue = value;
		if ( oldValue == expectedValue ) {
			value = newValue;
		}
		return oldValue;
	}
}
```

`CAS 的缺点`

ABA 问题 ： 误以为没有修改过，使用版本号可以解决

自旋时间过长

（ 更新中 ）
