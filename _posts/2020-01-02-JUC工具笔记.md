---
layout: post
title:  "JUC工具笔记"
date:   2020-01-02
desc: ""
keywords: ""
categories: [Java]
tags: []
icon: icon-html
---

Java 并发编程实战 + 并发工具详解 课程笔记 

<br />
# ThreadLocal

### `ThreadLocal 的两大使用场景`

+ 每个线程需要一个**独享的对象**（ 通常是工具类，典型的有 SimpleDateFormat 和 Random ）

```
SimpleDateFormat dateFormat = ThreadSafeFormatter.dateFormatThreadLocal.get();

......

// 在 ThreadLocal 第一次 get 的时候把对象给初始化出来，
// 对象的初始化时机可以由我们控制

class ThreadSafeFormatter {
	public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal = new ThreadLocal<SimpleDateFormat>() {
		@Override
		protected SimpleDateFormat initialValue() {
			return new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
		}
	};
}
```

+ 每个线程内需要**保存全局变量**（ 例如在拦截器中获取用户信息 ），可以让不同方法直接使用，避免参数传递的麻烦

在线程生命周期内，都通过这个静态 ThreadLocal 实例的 get() 方法取得自己 set 过的那个对象，强调了同一个请求内（ 同一个线程内 ）不同方法间的共享，不需重写 initialValue() 方法，但是必须手动调用 set() 方法

这样无需 synchronized，不影响性能，也无需层层传递参数

```
// 对象的生成时机不由我们随意控制

class UserContextHolder {
	public static ThreadLocal<User> holder = new ThreadLocal<>();
}

class Service1 {
	public void process() {
		User user = new User("Tom");
		UserContextHolder.holder.set(user);
		new Service2.process();
	}
}

class Service2 {
	public void process() {
		User user = UserContextHolder.holder.get();
		System.out.println(user.name);
	}
}
```

<br />
### `ThreadLocal 的两个作用`

1. 让某个需要用到的对象在线程间隔离（ 每个线程都有自己的独立的对象 ）
2. 在任何方法中都可以轻松获取到该对象

<br />
### `ThreadLocal 原理`

<div><img src="https://raw.githubusercontent.com/Tianye-Zheng/Tianye-Zheng.github.io/master/PostPictures/2019-winter/8.png" width = "420" height =
"430" /></div>

<br />
### `ThreadLocal 重要方法`

+ `T initialValue()` ： 该方法返回当前线程对应的 “初始值”，这是一个延迟加载的方法，只有在调用 get 的时候，才会触发

+ `void set(T t)` ： 为这个线程设置一个新值

+ `T get()`

+ `remove()`

<br />
### `ThreadLocalMap 类`

ThreadLocalMap 解决散列冲突采用**线性探测法**，也就是如果发生冲突，就继续找下一个空位置，而不是用链表拉链

<br />
### `两种使用场景殊途同归`

通过源码分析看出，setInitialValue 和直接 set 最后都是利用 **map.set()** 方法来设置值

也就是说，最后都会对应到 ThreadLocalMap 的一个 Entry，只**不过是起点和入口不一样**

<br />
### `ThreadLocal 注意点`

`内存泄漏` ： ThreadLocalMap 中的每个 Entry 都是一个对 key （ ThreadLocal ）的弱引用，同时，每个 Entry 都包含了一个对 value 的强引用

弱引用的特点是，如果这个对象只被弱引用关联（ 没有任何强引用关联 ），那么这个对象就可以被回收

通常情况下，当线程终止，保存在 ThreadLocal 里的 value 会被垃圾回收，因为没有任何强引用了

但是，如果线程不终止，比如线程需要保持很久，那么 key 对应的 value 就不能被回收，因为有以下的调用链：

`Thread -> ThreadLocalMap -> Entry(key 为 null) -> value`

因为 value 和 Thread 之间还存在这个强引用链路，所以导致 value 无法回收，就可能会出现 OOM

JDK 已经考虑到了这个问题，所以在 **set， remove， rehash** 方法中会**扫描 key 为 null 的 Entry，并把对应的 value 设置为 null**，这样 value 对象就可以被回收

但是如果一个 ThreadLocal 不被使用，那么实际上 set，remove， rehash 方法也不会被调用，如果同时线程又不停止，那么调用链就一直存在，那么就导致了 value 的内存泄漏

`如何避免内存泄漏（ 阿里规约 ）` ： 调用 remove 方法，就会删除对应的 Entry 对象，可以避免内存泄漏，所以使用完 ThreadLocal 之后，应该调用 remove 方法

`空指针异常` ： 在 get 之前，必须先 set，否则可能会报空指针异常，注意装箱拆箱时

`共享对象` ： 如果在每个线程中 ThreadLocal.set() 进去的东西本来就是多线程共享的同一个对象，比如 static 对象，那么多个线程的 ThreadLocal.get() 取得的还是这个共享对象本身，还是有并发访问问题

优先使用框架提供的，避免上述问题，例如

Spring 中的 DateTimeContextHolder 类，RequestContextHolder 类

**每次 HTTP 请求都对应一个线程，线程之间相互隔离，这就是 ThreadLocal 的典型应用场景**

<br />
# 线程池

<br />
### `线程池适用场景`

+ 服务器接受到大量请求时，适用线程池技术是非常合适的，它可以大大减少线程的创建和销毁次数，提高服务器的工作效率，例如 Tomcat 服务器也使用了线程池来实现

+ 实际上，在开发中，如果需要创建 5 个以上的线程，那么就可以使用线程池来管理

<br />
### `创建和停止线程池`

<div><img src="https://raw.githubusercontent.com/Tianye-Zheng/Tianye-Zheng.github.io/master/PostPictures/2019-winter/9.png" width = "500" height =
"430" /></div>

<div><img src="https://raw.githubusercontent.com/Tianye-Zheng/Tianye-Zheng.github.io/master/PostPictures/2019-winter/10.png" width = "500" height =
"430" /></div>
