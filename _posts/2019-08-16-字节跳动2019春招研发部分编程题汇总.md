---
layout: post
title:  "字节跳动2019春招研发部分编程题汇总"
date:   2019-08-16
desc: ""
keywords: ""
categories: [杂项]
tags: [真题]
icon: icon-html
---
来自牛客网



<br />
### 1、

我叫王大锤，是一家出版社的编辑。我负责校对投稿来的英文稿件，这份工作非常烦人，因为每天都要去修正无数的拼写错误。但是，优秀的人总能在平凡的工作中发现真理。我发现一个发现拼写错误的捷径：

1. 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -> hello
2. 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -> hello
3. 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC

**输入描述:**

第一行包括一个数字N，表示本次用例包括多少个待校验的字符串。

后面跟随N行，每行为一个待校验的字符串。

**输出描述:**

N行，每行包括一个被修复后的字符串。

**输入例子1:**

2

helloo

wooooooow

**输出例子1:**

hello

woow


```
import java.util.*;

public class Main {

    private static  StringBuilder toProcess;

    public static void main(String[] args){

        Scanner scan = new Scanner(System.in);
        int N = scan.nextInt();
        for (int i = 0; i < N; i++) {
            String rawString = scan.next();
            toProcess = new StringBuilder(rawString);
            for (int j = 0; j < toProcess.toString().length(); j++) {
                while(Judge(j));
            }
            System.out.println(toProcess.toString());
        }
    }

    public static boolean Judge(int index) {
        if((toProcess.toString().length()>=index+3)&&
                (toProcess.charAt(index) == toProcess.charAt(index+1)))
        {
            if(toProcess.charAt(index) == toProcess.charAt(index+2))
            {
                toProcess.deleteCharAt(index+1);
                return true;
            }
            else if((toProcess.toString().length()>=index+4)&&
                    (toProcess.charAt(index+2) == toProcess.charAt(index+3)))
            {
                toProcess.deleteCharAt(index+2);
                return true;
            }
        }
        return false;
    }
}
```

<br />
### 2、

我叫王大锤，是一名特工。我刚刚接到任务：在字节跳动大街进行埋伏，抓捕恐怖分子孔连顺。和我一起行动的还有另外两名特工，我提议

1. 我们在字节跳动大街的N个建筑中选定3个埋伏地点。
2. 为了相互照应，我们决定相距最远的两名特工间的距离不超过D。

请听题：给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。
注意：
1. 两个特工不能埋伏在同一地点
2. 三个特工是等价的：即同样的位置组合(A, B, C) 只算一种埋伏方法，不能因“特工之间互换位置”而重复使用

**输入描述:**

第一行包含空格分隔的两个数字 N和D(1 ≤ N ≤ 1000000; 1 ≤ D ≤ 1000000)

第二行包含N个建筑物的的位置，每个位置用一个整数（取值区间为[0, 1000000]）表示，从小到大排列（将字节跳动大街看做一条数轴）

**输出描述:**

一个数字，表示不同埋伏方案的数量。结果可能溢出，请对 99997867 取模

**输入例子1:**

4 3

1 2 3 4

**输出例子1:**

4

**例子说明1:**

可选方案 (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)

**输入例子2:**

5 19

1 10 20 30 50

**输出例子2:**

1

**例子说明2:**

可选方案 (1, 10, 20)

```
// 时间超限，仅能过部分用例
import java.util.*;

public class Main {

    public static void main(String[] args){

        Scanner scan = new Scanner(System.in);
        int N = scan.nextInt();
        int D = scan.nextInt();
        int[] buildings = new int[N];
        for (int i = 0; i < N; i++) {
            buildings[i] = scan.nextInt();
        }
        // start analyzing
        int result = 0;
        for (int i = 0; i < N; i++) {
            int num = 1;
            for (int j = i+1; j < N; j++) {
                if(buildings[j] - buildings[i] <= D)
                    num++;
            }
            if(num > 2) {
                result += (num-1)*(num-2) / 2;
                if(result >= 99997867)
                    result %= 99997867;
            }
        }
        System.out.println(result);
    }
}
```

<br />
### 3、

小包最近迷上了一款叫做雀魂的麻将游戏，但是这个游戏规则太复杂，小包玩了几个月了还是输多赢少。 
于是生气的小包根据游戏简化了一下规则发明了一种新的麻将，只留下一种花色，并且去除了一些特殊和牌方式（例如七对子等），具体的规则如下： 

	1.	总共有36张牌，每张牌是1~9。每个数字4张牌。 
	2.	你手里有其中的14张牌，如果这14张牌满足如下条件，即算作和牌 
	•	14张牌中有2张相同数字的牌，称为雀头。 
	•	除去上述2张牌，剩下12张牌可以组成4个顺子或刻子。顺子的意思是递增的连续3个数字牌（例如234,567等），刻子的意思是相同数字的3个数字牌（例如111,777） 

例如： 

1 1 1 2 2 2 6 6 6 7 7 7 9 9 可以组成1,2,6,7的4个刻子和9的雀头，可以和牌 

1 1 1 1 2 2 3 3 5 6 7 7 8 9 用1做雀头，组123,123,567,789的四个顺子，可以和牌 

1 1 1 2 2 2 3 3 3 5 6 7 7 9 无论用1 2 3 7哪个做雀头，都无法组成和牌的条件。 

现在，小包从36张牌中抽取了13张牌，他想知道在剩下的23张牌中，再取一张牌，取到哪几种数字牌可以和牌。 


**输入描述:**

输入只有一行，包含13个数字，用空格分隔，每个数字在1~9之间，数据保证同种数字最多出现4次。

**输出描述:**

输出同样是一行，包含1个或以上的数字。代表他再取到哪些牌可以和牌。若满足条件的有多种牌，请按从小到大的顺序输出。若没有满足条件的牌，请输出一个数字0

**输入例子1:**

1 1 1 2 2 2 5 5 5 6 6 6 9

**输出例子1:**

9

**例子说明1:**

可以组成1,2,6,7的4个刻子和9的雀头

**输入例子2:**

1 1 1 1 2 2 3 3 5 6 7 8 9

**输出例子2:**

4 7

**例子说明2:**

用1做雀头，组123,123,567或456,789的四个顺子

**输入例子3:**

1 1 1 2 2 2 3 3 3 5 7 7 9

**输出例子3:**

0

**例子说明3:**

来任何牌都无法和牌

```
// 通过10%，空间超限
import java.util.*;

public class Main {

    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        ArrayList<Integer> list = new ArrayList<>(13);
        for (int i = 0; i < 13; i++) {
            list.add(scan.nextInt());
        }
        Collections.sort(list);

        for (int i = 0; i < 9; i++) {
            boolean canAdd = true;
            for (int j = 0; j <= 9; j++) {
                if((list.get(j) == i+1) && (list.get(j+3) == i+1))
                    canAdd = false;
            }
            if(canAdd) {
                ArrayList<Integer> list1 = new ArrayList<>(list);
                list1.add(i+1);
                Collections.sort(list1);
                if(Judge(list1)) System.out.print(i + 1);
            }
        }
    }

    private static boolean Judge(ArrayList<Integer> list1) {
        boolean[] beHead = new boolean[9];
        for (int i = 0; i < 9; i++) {
            beHead[i] = true;
        }
        for (int i = 0; i < list1.size()-1; i++) { // try by number
            if((list1.get(i).equals(list1.get(i+1))) && beHead[list1.get(i)]) {
                beHead[list1.get(i)] = false;
                ArrayList<Integer> list2 = new ArrayList<>(list1);
                list2.remove(i);
                list2.remove(i); // remove the head
                // begin judging without head (12)
                while(!list2.isEmpty()) {
                    if((list2.size() >= 3)&&(list2.get(0)==list2.get(2))) {
                        list2.remove(0);
                        list2.remove(0);
                        list2.remove(0);
                    }
                    else if(list2.contains(list2.get(0)+1)&&
                            list2.contains(list2.get(0)+2)) {
                        list2.remove(list2.get(0));
                        list2.remove(new Integer(list2.get(0)+1));
                        list2.remove(new Integer(list2.get(0)+1));
                    }
                    else break;
                }
                if(list2.isEmpty()) return true;
            }
        }
        return false;
    }
}
```

<br />
### 4、

小明是一名算法工程师，同时也是一名铲屎官。某天，他突发奇想，想从猫咪的视频里挖掘一些猫咪的运动信息。为了提取运动信息，他需要从视频的每一帧提取“猫咪特征”。一个猫咪特征是一个两维的 vector\<x, y\>。如果 x\_1=x\_2 and y\_1=y\_2，那么这俩是同一个特征。 

因此，如果喵咪特征连续一致，可以认为喵咪在运动。也就是说，如果特征 \<a, b\> 在持续帧里出现，那么它将构成特征运动。比如，特征 \<a, b\> 在第 2/3/4/7/8 帧出现，那么该特征将形成两个特征运动 2-3-4 和 7-8。 
现在，给定每一帧的特征，特征的数量可能不一样。小明期望能找到最长的特征运动。 

**输入描述:**

第一行包含一个正整数N，代表测试用例的个数。

每个测试用例的第一行包含一个正整数M，代表视频的帧数。

接下来的M行，每行代表一帧。其中，第一个数字是该帧的特征个数，接下来的数字是在特征的取值；比如样例输入第三行里，2代表该帧有两个猫咪特征，\<1，1\> 和 \<2，2\>

所有用例的输入特征总数和<100000

N满足1≤N≤100000，M满足1≤M≤10000，一帧的特征个数满足 ≤ 10000。
特征取值均为非负整数。

**输出描述:**

对每一个测试用例，输出特征运动的长度作为一行

**输入例子1:**

1

8

2 1 1 2 2

2 1 1 1 4

2 1 1 2 2

2 2 2 1 4

0

0

1 1 1

1 1 1

**输出例子1:**

3

**例子说明1:**

特征 \<1,1\> 在连续的帧中连续出现3次，相比其他特征连续出现的次数大，所以输出3

参考 [Map对象中的keyset()、entryset()和Map.Entry](https://blog.csdn.net/weixin_40216444/article/details/82794019)

```
import java.util.*;

public class Main {

    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int N = scan.nextInt();
        for (int i = 0; i < N; i++) { // for every test case
            HashMap<String,Integer> hashMap = new HashMap<>();
            int result = 1;
            int M = scan.nextInt();
            for (int j = 0; j < M; j++) {
                int currentNum = scan.nextInt();
                HashMap<String,Integer> oneLineMap = new HashMap<>();
                for (int k = 0; k < currentNum; k++) { // vectors in one line
                    int left = scan.nextInt();
                    int right = scan.nextInt();
                    String toAdd = Integer.toString(left) + "," + Integer.toString(right);
                    oneLineMap.put(toAdd,1);
                }
                
//                注释掉的遍历方法是错误的，会导致遍历删除出错
//                Set<Map.Entry<String,Integer>> entrySet = hashMap.entrySet(); // 遍历 hashMap
//                for (Map.Entry<String,Integer> entry : entrySet) {
//                    if(oneLineMap.containsKey(entry.getKey())) {
//                        int newNum = hashMap.get(entry.getKey())+1;
//                        if(newNum > result) result = newNum;
//                        hashMap.put(entry.getKey(),hashMap.get(entry.getKey())+1);
//                    }
//                    else {
//                        hashMap.remove(entry.getKey());
//                    }
//                }

                for (Iterator<Map.Entry<String,Integer>> it = hashMap.entrySet().iterator();it.hasNext();) {
                    Map.Entry<String,Integer> item = it.next();
                    if(oneLineMap.containsKey(item.getKey())) {
                        int newNum = hashMap.get(item.getKey()) + 1;
                        if(newNum > result) result = newNum;
                        hashMap.put(item.getKey(),hashMap.get(item.getKey())+1);
                    }
                    else {
                        it.remove();
                    }
                }
                Set<Map.Entry<String,Integer>> oneLineEntrySet = oneLineMap.entrySet(); // 遍历 oneLineMap
                for (Map.Entry<String,Integer> entry : oneLineEntrySet) {
                    if(!hashMap.containsKey(entry.getKey())) {
                        hashMap.put(entry.getKey(),1);
                    }
                }
            }

            System.out.println(result);
        }
    }
}
```

<br />
### 5、

<br />
### 6、

Z国的货币系统包含面值1元、4元、16元、64元共计4种硬币，以及面值1024元的纸币。现在小Y使用1024元的纸币购买了一件价值为￼的商品，请问最少他会收到多少硬币？

**输入描述:**

一行，包含一个数N。

**输出描述:**

一行，包含一个数，表示最少收到的硬币数。

**输入例子1:**

200

**输出例子1:**

17

**例子说明1:**

花200，需要找零824块，找12个64元硬币，3个16元硬币，2个4元硬币即可。

```
#include <iostream>
using namespace std;
 
int main(){
    int N;
    cin>>N;
    N=1024-N;
    //顺序执行
    // int count0=0,count1=0,count2=0,count3=0,count=0;
    // count0=N/64;
    // N=N%64;
    
    // count1 =N/16;
    // N=N%16;
    
    // count2 = N/4;
    // N = N%4;
 
    // count3 = N/1;
    // count = count0+count1+count2+count3;
    
    //特殊情况，
    // int x=64,count=0;
    // while(N!=0){
    //     count+=N/x;
    //     N=N%x;
    //     x/=4;
    // }
    
    //学习定义一个int 数组int coins[4]={64,16,4,1};
    int count =0;
    int coins[4]={64,16,4,1};
    for(int i=0;i<4;i++){
        count+=N/coins[i];
        N=N%coins[i];
    }
 
    cout<<count<<endl;
    return 0;
}
 
 ———————————————— 
版权声明：本文为CSDN博主「渣渣pxk」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u014439564/article/details/89684266
```

<br />
### 7、

机器人正在玩一个古老的基于DOS的游戏。游戏中有N+1座建筑——从0到N编号，从左到右排列。编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位。  

起初， 机器人在编号为0的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E, 下一步它将跳到第个k+1建筑。它将会得到或者失去正比于与H(k+1)与E之差的能量。如果 H(k+1) > E 那么机器人就失去 H(k+1) - E 的能量值，否则它将得到 E - H(k+1) 的能量值。 

游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？ 

**输入描述:**

第一行输入，表示一共有 N 组数据.

第二个是 N 个空格分隔的整数，H1, H2, H3, ..., Hn 代表建筑物的高度

**输出描述:**

输出一个单独的数表示完成游戏所需的最少单位的初始能量

**输入例子1:**

5

3 4 3 2 4

**输出例子1:**

4

**输入例子2:**

3

4 4 4

**输出例子2:**

4

**输入例子3:**

3

1 6 4

**输出例子3:**

3
