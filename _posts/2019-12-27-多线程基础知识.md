---
layout: post
title:  "多线程基础知识"
date:   2019-12-27
desc: ""
keywords: ""
categories: [Java]
tags: []
icon: icon-html
---

java 多线程笔记

<br />
## 线程如何正确停止
<br />

正确地停止线程：**使用 interrupt 来通知，而不是强制**

通常情况下建议某个线程停止

`thread.interrupt();`

线程内检测是否被建议终止,然后由被终止线程来做出响应

`Thread.currentThread().isInterrupted();`

当停止线程遇到线程阻塞，则被停止线程会跑出异常，在异常处理过程中来响应

`try { Thread.sleep(1000); } catch { InterruptedException e }`

如果在线程执行过程中，每次循环都会调用 sleep 或 wait 等方法，那么不需要每次迭代都检查是否已中断

响应中断之后，便会把 interrupted **标记位清除**，所以 catch 到异常之后再检测 isInterrupted() 是 false

实际开发中处理线程中断的最佳实践：

+ 优先选择：传递中断，在方法签名中抛出异常，那么在 run() 中就会强制 try/catch
+ 不想或无法传递：恢复中断，在 catch 子语句中调用 `Thread.currentThread().interrupt()` 来恢复设置中断状态，以便在后续的执行中，依然能够检测到刚才发生了中断
+ 不应屏蔽中断

错误的线程停止方法：

+ 被弃用的 stop，suspend 和 resume 方法：用 stop 方法会导致线程突然停止，无法完成基本单位的操作，造成脏数据

+ 用 volatile 设置 boolean 标记位，当线程被阻塞时，用 volatile 变量无法停止

判断是否已被中断相关方法：

+ `boolean isInterrupted()` ：判断是否被(建议)中断，底层是 `return isInterrupted(false)`
+ `static boolean interrupted()` ：不过**会清除中断状态** (唯一能清除中断状态的办法)，底层是 `return isInterrupted(true)`，**目标对象是当前运行的线程**

**Q**: 如何处理不可中断的阻塞

**A**: 没有通用的解决方案，针对特定情况使用特定方法

<br />
## 图解线程生命周期
<br />

<div align="center"><img src="https://raw.githubusercontent.com/Tianye-Zheng/Tianye-Zheng.github.io/master/PostPictures/2019-winter/1.png" width = "400" height =
"400" /></div>