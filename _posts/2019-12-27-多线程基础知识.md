---
layout: post
title:  "多线程基础知识"
date:   2019-12-27
desc: ""
keywords: ""
categories: [Java]
tags: []
icon: icon-html
---

线程八大核心 + Java并发底层原理精讲 课程笔记






<br />
## 线程如何正确停止
<br />

正确地停止线程：**使用 interrupt 来通知，而不是强制**

通常情况下建议某个线程停止

`thread.interrupt();`

线程内检测是否被建议终止,然后由被终止线程来做出响应

`Thread.currentThread().isInterrupted();`

当停止线程遇到线程阻塞，则被停止线程会抛出异常，在异常处理过程中来响应

`try { Thread.sleep(1000); } catch { InterruptedException e }`

如果在线程执行过程中，每次循环都会调用 sleep 或 wait 等方法，那么不需要每次迭代都检查是否已中断

响应中断之后，便会把 interrupted **标记位清除**，所以 catch 到异常之后再检测 isInterrupted() 是 false

实际开发中处理线程中断的最佳实践：

+ 优先选择：传递中断，在方法签名中抛出异常，那么在 run() 中就会强制 try/catch
+ 不想或无法传递：恢复中断，在 catch 子语句中调用 `Thread.currentThread().interrupt()` 来恢复设置中断状态，以便在后续的执行中，依然能够检测到刚才发生了中断
+ 不应屏蔽中断

错误的线程停止方法：

+ 被弃用的 stop，suspend 和 resume 方法：用 stop 方法会导致线程突然停止，无法完成基本单位的操作，造成脏数据

+ 用 volatile 设置 boolean 标记位，当线程被阻塞时，用 volatile 变量无法停止

判断是否已被中断相关方法：

+ `boolean isInterrupted()` ：判断是否被(建议)中断，底层是 `return isInterrupted(false)`
+ `static boolean interrupted()` ：不过**会清除中断状态** (唯一能清除中断状态的办法)，底层是 `return isInterrupted(true)`，**目标对象是当前运行的线程**

**Q**: 如何处理不可中断的阻塞

**A**: 没有通用的解决方案，针对特定情况使用特定方法

<br />
## 图解线程生命周期
<br />

<div><img src="https://raw.githubusercontent.com/Tianye-Zheng/Tianye-Zheng.github.io/master/PostPictures/2019-winter/1.png" width = "420" height =
"430" /></div>

一般习惯而言，把 Blocked (被阻塞), Waiting (等待), Timed_Waiting (计时等待) 都称为阻塞状态

<br />
## Thread 和 Object 类中的重要方法
<br />

### Object
<br />

`wait、notify、notifyAll` : 控制线程的休息和唤醒，都需要在 synchronize 保护的代码或方法块中执行，否则抛出异常，哪一个对象执行 wait 就只会释放掉哪一个对象的锁，使用 notify 时必须先拥有 monitor ，否则会抛出异常

手写生产者消费者模式：用 wait、notify 实现

<div><img src="https://raw.githubusercontent.com/Tianye-Zheng/Tianye-Zheng.github.io/master/PostPictures/2019-winter/2.png" width = "400" height =
"400" /></div>

```
class EventStorage {
    private int maxSize;
    private LinkedList<Date> storage;

    public EventStorage() {
        maxSize = 10;
        storage = new LinkedList<>();
    }

    public synchronized void put() {
        while (storage.size() == maxSize) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        storage.add(new Date());
        System.out.println("仓库里有了" + storage.size() + "个产品。");
        notify();
    }

    public synchronized void take() {
        while (storage.size() == 0) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("拿到了" + storage.poll() + "仓库中还剩下" + storage.size());
        notify();
    }
}

class Producer implements Runnable {

    private EventStorage storage;

    public Producer(EventStorage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        for(int i = 0; i < 100; i++) {
            storage.put();
        }
    }
}

class Consumer implements Runnable {

    private EventStorage storage;

    public Consumer(EventStorage storage) {
        this.storage = storage;
    }

    @Override
    public void run() {
        for(int i = 0; i < 100; i++) {
            storage.take();
        }
    }
}

public class Main {

    public static void main(String[] args) {
        EventStorage eventStorage = new EventStorage();
        Producer producer = new Producer(eventStorage);
        Consumer consumer = new Consumer(eventStorage);
        new Thread(producer).start();
        new Thread(consumer).start();
    }
}
```

**Q**: 为什么 wait() 需要在**同步代码块**中使用，而 sleep() 不需要

**A**: 为了防止死锁或永久等待的发生。如果不把 wait 和 notify 都放在代码块里面保护的话，有可能执行 wait 之前线程突然切过去了，切换到另外一个执行 notify 的线程，另外的线程把 notify 都执行完了，切回来之后 wait 无法唤醒。所以设计者把线程之间需要配合的情况都放到了同步代码块中

**Q**: 为什么线程通信的方法 wait()，notify() 和 notifyAll() 被定义在 Object 类里，而 sleep 定义在 Thread 类里？

**A**: 在 Java 中这三个方法是锁级别的操作，而锁是属于某一个对象的

<br />
### Thread
<br />

`sleep` : 只想让线程在预期的时间执行，其它时间不占用 CPU 资源，这个方法**不释放锁**（ 包括 synchronized 和 lock ）sleep 方法响应中断：1. 跑出 InterruptedException 异常，2. 清除中断状态 事实上，只要响应这个异常都会清除中断状态

**Q**: 你知道 wait 和 sleep 方法的异同吗？

**A**: 

相同 1 ： wait 和 sleep 都可以使线程阻塞，对应状态是 Waiting 和 Timed_Waiting

相同 2 ： wait 和 sleep 都可以响应中断 Thread.interrupt()

不同 1 ： wait 必须在同步方法中执行，而 sleep 不需要

不同 2 ： 执行 sleep 不会释放 monitor 锁，但是 wait 会释放 monitor 锁

不同 3 ： sleep 休眠之后会主动退出阻塞，而没有指定时间的 wait 则需要被其它线程中断之后才能退出阻塞

不同 4 ： wait 是 Object 类的方法，sleep 是 Thread 类的方法

`join` : 作用：因为新的线程加入了我们，所以我们要等待他执行完再出发，用法：main 等待 thread1 执行完毕，主线程在等待子线程 join 期间如果遇到中断可以把中断传递给子线程，避免不一致。join 期间，线程处于 Waiting 状态

thread.join() 等价代码

```
synchronize (thread) {
	thread.wait(); // 主线程陷入休眠状态
}
```

尽量使用成熟的工具类 CountDownLatch 或 CyclicBarrier

`yield` : 释放我的 CPU 时间片，释放之后状态依然是 Runnable，因为不会释放锁，也不会陷入阻塞

<br />
## 线程重要属性概览
<br />

`线程ID` : ID 从 1 开始递增，JVM 运行起来后，我们自己创建的线程 ID 早已不是 2

`守护线程` : 给用户线程提供服务，不会影响 JVM 的退出。线程类型默认继承自父线程。不应该把自己的线程设置成守护线程

`线程优先级` : 10 个级别，默认为 5

<br />
## 线程异常处理
<br />

线程异常不能用传统方式来捕获，主线程当中的 try/catch 不能捕获子线程的异常

线程的未捕获异常 UncaughtException 应该如何处理？ 两种解决方案：

方案一 ( 不推荐 ) ： 手动在每个 run 方法里进行 try / catch

方案二 ( 推荐 ) ： 利用 UncaughtExceptionHandler 接口

`void uncaughtException(Thread t, Throwable e);`

自己实现：

+ 给程序统一设置
+ 给每个线程单独设置
+ 给线程池设置

```
class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {

    private String name;

    public MyUncaughtExceptionHandler(String name) {
        this.name = name;
    }

    @Override
    public void uncaughtException(Thread t, Throwable e) {
        Logger logger = Logger.getAnonymousLogger();
        logger.log(Level.WARNING,"线程异常：" + t.getName(), e);
        System.out.println(name + " 捕获了异常" + e);
    }
}

class UserOwnUncaughtExceptionHandler implements Runnable {

    @Override
    public void run() {
        throw new RuntimeException();
    }

    public static void main(String[] args) throws InterruptedException{
        Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandler("捕获器1"));

        new Thread(new UserOwnUncaughtExceptionHandler(), "MyThread-1").start();
        new Thread(new UserOwnUncaughtExceptionHandler(), "MyThread-2").start();
        new Thread(new UserOwnUncaughtExceptionHandler(), "MyThread-3").start();
        new Thread(new UserOwnUncaughtExceptionHandler(), "MyThread-4").start();
    }
}
```

<br />
## 并发安全
<br />

`线程安全` ： 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的

什么情况下会出现线程安全问题：

+ 运行结果错误：a++ 多线程下出现消失的请求现象
+ 活跃性问题：死锁、活锁、饥饿
+ 对象发布和初始化的时候的安全问题

